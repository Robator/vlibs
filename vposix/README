//=======================================================================================
//      VPOSIX README
//=======================================================================================

    Задача текущего проекта -- собирать в одном месте вызовы линуховских функций, чтобы
хоть как-то их систематизировать.

    Речь идет о, хотя бы, примитивных обертках с ожидаемыми параметрами в сигнатурах.
Также речь идет об их сортировке по разделам, а не типа вот такой гадости: <fcntl.h>.

    Предполагается, что любые системные вызовы проходят через этот проект, чтобы, по
крайней мере, каталогизировать вызовы. При появлении глюков/особенностей вызовов чтобы
было где комментировать, исправлять, костылить.

    Также важной задачей (к сожалению, не всегда успешно решенной) является
инкапсулирование включений системных заголовков, проксирование их функциональности.
Это чтобы системные сущности не пролезали в библиотечный и бизнес слои. Имеется ввиду,
чтобы включений #include <some/system-lib.h> не было в заголовках vposix_*.h. Тогда очень
содержательные системные макросы, структуры, typedef-ы и пр. не пролезут в рабочий код.

    UPD: 27-11-2018
    //===================================================================================
    vposix_core
    //===================================================================================
        Содержит два класса:
            class Core: содержит методы-шаблоны:

            linux_call_or_err( linux_func, args... ) -- вызывает в цикле функцию, как
                только проскочит через EINTR [см. *], вернет полученное значение.

            linux_call( linux_func, args... ) -- прокрутит вызов и, в случае ошибки,
                сразу же бросит исключение. Например, вызов:
                {
                    return Core::linux_call( ::close, fd );
                }
                Эквивалентен:
                {
                    int res;
                    do
                    {
                        res = ::close( fd );
                    }
                    while ( res == -1 && errno == EINTR ); // [см. *]

                    if ( res == -1 )
                    {
                        char buf[1024];
                        throw verror( strerror_r( errno, buf, 1024 ); );
                    }

                    return res;
                }
            Методы помогают не забывать проверять коды возврата и не писать кучу овнеа.

            [*] EINTR -- специальная ошибка в linux-е, которая возникает, если вызов
                         системной функции прервался сигналом. Ни один системный вызов
                         не застрахован от этой ошибки. Возникает редко, но метко.
                         Зачем и почему надо было городить эту яму с острыми кольями и
                         гремучими змеями для автора загадка, например BSD системы этим
                         не болеют. В любом случае, это весомый аргумент, чтобы
                         проводить всякое общение с системой в отдельной, хорошо
                         проветриваемой и изолированной палате.

    //===================================================================================
            class Errno: при создании захватывает errno, инкапсулирует имена
                макросов-ошибок до названий, приближенных к c++ (см. ссылку в .h).

            В случае наличия ошибки, позволяет быстро ее пробросить:
                Errno e; ...; e.throw_error();

    //===================================================================================
     vposix_core
    //===================================================================================

//=======================================================================================
//      VPOSIX README
//=======================================================================================


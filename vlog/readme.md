VLOG -- проект по логгированию действий в программах.

-----------------------------------------------------------------------------------------
Процесс логгирования:
-----------------------------------------------------------------------------------------
В qt лог подключается:  include( $$VLibs_Dir/vlog/vlog.pri )
В cmake:                include( "${VLIBS_PATH}/vlog/vlog.cmake" )

Для начала логгирования необходимо включить в исходник:
    #define "vlog.h"

Логгирование производится через макросы:
    VTRACE
    VDEBUG
    VRUNLOG
    VWARNING
    VFATAL

Действуют интерфейсы потоков, а также перегружен оператор () с произвольным 
количеством аргументов. 

Т.е. разрешены такие конструкции как:
int ii; 
double dd; 
string ss; 
float ff;
  // будет логгироваться при включении проекта vchrono и заголовка #define "vtimepoint.h"
  chrono::milliseconds ms;    

VTRACE( "text", ii, dd, ss, ms );
VDEBUG ("text")(ii)(dd, ss)(ms);
VRUNLOG << "text" << ii << dd << ss << ms;

Действуют все стандартные модификаторы, часть из них вынесена в отдельные методы:
VWARNING.max_presicion()(dd).presicion(4)(ff).hex()(ii)(std::oct, ii)

Добавлен модификатор vcat::space, vcat::nospace, включающий пробелы между аргументами.
Притом он ВКЛЮЧЕН ПО УМОЛЧАНИЮ. Также есть соответствующие перегруженные методы:
VFATAL.nospace() << "Filename '" << fname << "' does not exists!"; 
В примере выше, если не выключить пробелы, имя файла окажется не в кавычках, 
будут пробелы между ними.


Для любителей есть файл включения "vlog_pretty.h", повторяющий те же макросы 
в нижнем регистре. Также в нем содержится class VLogError : public std::exception, 
который можно использовать для бросания исключений:

if ( some_error )
    throw VLogError( vfatal << "Some problem" );
    
Метод what(), кроме сообщения, будет содержать точку, где было брошено исключение в виде:
[source.cpp:42] >> "Some problem";

-----------------------------------------------------------------------------------------
"Под капотом". Процесс записи, пересылки, составления и обработки логов. 
-----------------------------------------------------------------------------------------
При создании точки логгирования, создается класс VLogger, имеющий интерфейс vcat.
Когда он уничтожается, он формирует "точку вхождения" -- класс VLogEntry, который 
передается всем зарегистрированным исполнителям логов (через vlog::VLogger::execute).

"Исполнитель логов" (или просто "исполнитель") означает функциональную сущность типа
        using Executer = std::function< void(const VLogEntry &entry) >;
        
По умолчанию, "из коробки", в исполнителях логов находится один, логгирующий данные 
в консоль через метод vlog::VLogger::_log_to_cout( const VLogEntry &entry );

В классе vlog::VLogger есть статические методы:
        static void add_executer( Executer e );
        static void clear_executers();
которые позволяют добавлять своих исполнителей, а также сбрасывать всех исполнителей 
разом (делать селекционное отключение нет смысла, просто настраивайте один раз).

Написаны исполнители логов в файлы с ротацией, для их использования надо подключить: 
include( $$VLibs_Dir/vlog/vfilelog.pri )
Есть вариант логгирования в один файл, в файлы по типу сообщения; 
Есть исполнители в отдельном потоке, или без потокобезопасности.


-----------------------------------------------------------------------------------------
За разъяснениями и дополнительной информацией -- пинайте автора, он понимает, что 
написано сумбурно. Опять же, помогите сделать текст понятнее.
-----------------------------------------------------------------------------------------




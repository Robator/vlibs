=========================================================================================
Здесь думается собирать вопросы, непонятки, темы для обсуждений, холивары и прочие
рабочие процессы.
=========================================================================================


=========================================================================================
27.11.2018  Q1 -- VApplication::Args    by Elapidae

Задним числом осознана неприятность в VApplication::Args. Подробный пример в .h файле,
вкратце: если постепенно выбирать аргументы, то можно получить странные эффекты.


Первое: можно исправить поведение следующим образом:
В начале сделать копию аргументов;
по мере выборки, искать значения на неизменяемой копии, а удалять из второго списка.
Соответственно, сохранить проверку количества и правильности аргументов, но исправить
токсичное поведение. Но сначала, стоИт похоливарить [trollface].


Второе: существуют уже "готовые" решения:
posix-овый способ: https://habr.com/post/55665/
Boost [не предлагать].
ваш вариант...

По мне так, posix-способ просто токсичен. Странный синтаксис, странный обход, который
контролирует логику программы, а не наоборот, очень многословное решение -- чтобы
вытащить три опции switch разваливается на полтора экрана. Но, с другой стороны, кому-то
"привычный" и более менее универсальный.
 - есть возможность делать группировку опций-флагов: "-a -b -c" == "-abc".
        Мне лично эта группировка ни разу не пригодилась. Я ее, вообще, не сильно жалую.
 - есть длинные-короткие опции: "--list" == "-l".
        Неплохо, но, опять же, не особо востребованная фича.

Boost, очевидно, не в нашей весовой категории.

Вопросы:
Нужен ли нам другой способ парсинга аргументов (или текущего подхода достаточно)?
Надо ли делать какой-то универсальный механизм разбора командной строки, если да,
то какой?

Решатели:   - подход к парсингу -- posix-way VS human-way
                * posix-way -- сначала, некоторым способом, задаем список опций, потом
                    парсим. Необязательно будет libc реализация (даже в Qt свое есть).
                    М/б преимущество: автодокументация.
                    Недостаток: Сложно реализовать понятно и удобно, не через нопу.
                * human-way -- извлекаем опции по мере желания:
                    args.take_flag();
                    args.take_std_value("key");

            - группировка флагов -- надо / нет

            - алиасы длинных и коротких опций -- надо / нет

            - можно запилить возможность понимать "из коробки" опции вида:
                "key=value" и "key:value" (естесственно, без пробелов) -- надо / нет
=========================================================================================


=========================================================================================
27.11.2018  Q2 -- VSignal VS VCallBack    by Elapidae

Есть такой класс: VSignal, его задача -- делать удобную инверсию зависимостей.
Если по русски: отвязывать интерфейсы производителей от потребителей.
// Нужно ли здесь объяснить и расшифровать подробнее?
// TODO: Придумать наглядный пример демонстрации инверсии зависимостей.

В стандартных случаях используется std::function, но, обычно, распыляют задачу на его
установку, проверку, вызов и пр. Многословно.
VSignal призван автоматизировать всю эту машинерию, подробнее см. vsignal.h.

Со временем набежали вопросы и сомнения:

 - VSignal позволяет соединиться с ним, но отсоединяется только при "смерти";

 - Имя достаточно нагружено, ненароком, могут спутать с одноименной гадостью из GNOME, а
    также с системными сигналами (которые SIGKILL, SIGTERM и пр. обфускации).

 - Реализована возможность соединять любое количество потребителей, но, по факту,
    в 99.9% случаев потребитель присоединяется один.

Хотелось бы обсудить и услышать мнения других:
 - что бы хотелось, какие фичи, плюшки?
 - как этот кейс воспринимается и решается другими?
 - есть ли альтернативные подходы вообще (есть, например, акторы) и для нас, в частности?

На будущее: сигналы (или их наследники) войдут в межпоточное взаимодействие.
=========================================================================================


=========================================================================================
10.12.2018  Q3 -- Управление подрепозиториями       by Elapidae

Предположим собирается проект, к которому подключены два субрепа: git-sub-A и git-sub-B.
В каждом их них используется vlibs. Притом написаны репозитории были в разное время, есть
расхождения по версиям vlibs.

Как поступать в подобных случаях?
Первый подход:
Подрепозитории не имеют права включать в себя другие подрепозитории, привязывать их к
себе. Пользоваться "услугами" других субрепов могут подразумевая их подключение к
проекту.
 + Все субрепы включены по одному разу, весь код общий, без дублирования.
 +- В случае "расползания" по версиям будет необходимость держать код в актуальном
    состоянии.
 - Отсутствие какого-либо контроля использованных версий со стороны git.
    Единственное, что приходит в голову чтобы держать хоть какие-то намеки на
    используемую версию -- сохранять хэши использованных субрепов в специально обученном
    файле. Такое решение трэшовое по определению, автоматизации поддается, но плохо.
    Ничего не дает, кроме возможности проводить увлекательные расследования.
 - плоская, плохо расширяемая модель.

Второй подход:
Подрепозитории включают используемые субрепы рекурсивно.
 + Можно держать код, обкатанный со своей весрией.
 - Надо что-то думать, чтобы версии не перекрывали друг друга, выглядеть будет страшно.
   Даже непонятно как такое собирать.

Я склоняюсь к первому подходу, но надо что-то думать за фиксацию. Очень жду ваши мысли.
=========================================================================================



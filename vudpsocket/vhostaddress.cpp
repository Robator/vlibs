#include "vhostaddress.h"

// bzero
#include <string.h>

// inet_aton etc
#include <arpa/inet.h>

#include <stdexcept>

#include "vlogger.h"

//=======================================================================================
//      В процессе разработки
//=======================================================================================



//=======================================================================================
//      HOST ADDRESS
//=======================================================================================
// http://www.opennet.ru/man.shtml?topic=inet_aton&category=3
// http://rsdn.org/article/unix/sockets.xml
// И ещё одно важное замечание. Существует два порядка хранения байтов в слове и двойном
// слове. Один из них называется порядком хоста (host byte order), другой - сетевым
// порядком (network byte order) хранения байтов. При указании IP-адреса и номера порта
// необходимо преобразовать число из порядка хоста в сетевой. Для этого используются
// функции htons (Host TO Network Short) и htonl (Host TO Network Long).
// Обратное преобразование выполняют функции ntohs и ntohl.
//=======================================================================================
//uint32_t VHostAddress::inet_ip() const
//{
//    return htonl( _ip );
//}
//=======================================================================================
//uint16_t VHostAddress::inet_port() const
//{
//    return htons( _port );
//}
//=======================================================================================
VHostAddress::VHostAddress()
{
    bzero( &_addr, sizeof _addr );
}
//=======================================================================================
VHostAddress::VHostAddress(const std::string &addr, uint16_t port)
    : VHostAddress()
{
    if ( !set_addr(addr) )
        throw std::runtime_error( "Error during set address " + addr );

    set_port( port );
}
//=======================================================================================
uint32_t VHostAddress::host_ip() const
{
    return ntohl( _addr.sin_addr.s_addr );
}
//=======================================================================================
uint16_t VHostAddress::get_port() const
{
    return ntohs( _addr.sin_port );
}
//=======================================================================================
std::string VHostAddress::str() const
{
    return varg(get_addr(), ":", get_port());
}
//=======================================================================================
// inet_aton(const char *cp, struct in_addr *inp)
// преобразовывает обычный вид IP-адреса cp (из номеров и точек) в двоичный код и
// сохраняет его в структуре, на которую указывает inp. inet_aton возвращает ненулевое
// значение, если адрес правильный, и возвращает ноль, если он неверен.

// in_addr_t inet_network(const char *cp)
// извлекает сетевой номер в хостовом порядке расположения байтов из адреса cp,
// записанном в виде номеров и точек. Если входящий адрес неверен, то возвращается -1.

// char *inet_ntoa(struct in_addr in)
// преобразует IP-адрес in, заданный в сетевом порядке расположения байтов, в стандартный
// строчный вид, из номеров и точек. Строка располагается в статически размещенном
// буфере; последующие вызовы перепишут его данные.
//=======================================================================================
bool VHostAddress::set_addr( const std::string &addr )
{
    return inet_aton( addr.c_str(), &_addr.sin_addr );
}
//=======================================================================================
std::string VHostAddress::get_addr() const
{
    return inet_ntoa( _addr.sin_addr );
}

void VHostAddress::set_port(uint16_t port)
{
    static_assert(sizeof port == sizeof _addr.sin_port, "sizeof port != _addr.sin_port");
    _addr.sin_port = ntohs( port );
}
//=======================================================================================
//      HOST ADDRESS
//=======================================================================================

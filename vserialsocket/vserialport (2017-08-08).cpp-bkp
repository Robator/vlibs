#include "vserialport.h"

#include <assert.h>

#include <sys/ioctl.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

//#include "logger_nav_gw.h"

#include <iostream>
#include "varg.h"
#include <type_traits>
#include <termios.h>

using namespace std;

// При чтении из порта в readAll() применяется как размер буффера на один запрос.
static constexpr auto one_buffer_size = 4096;



//=======================================================================================
speed_t to_speed_t( VSerialPort::Speed t )
{
    switch (t)
    {
    case   VSerialPort::Speed::S9600:   return   B9600;
    case  VSerialPort::Speed::S19200:   return  B19200;
    case VSerialPort::Speed::S115200:   return B115200;
    case VSerialPort::Speed::S230400:   return B230400;

    default:
        assert( false && "Port speed is undefined! Let write need speed..." );
        exit(10);
    }
}
//=======================================================================================
tcflag_t databits_mask(VSerialPort::DataBits db)
{

    switch(db)
    {
    case VSerialPort::DataBits::Data5: return CS5;
    case VSerialPort::DataBits::Data6: return CS6;
    case VSerialPort::DataBits::Data7: return CS7;
    case VSerialPort::DataBits::Data8: return CS8;

    default:
        assert( false && "Data bits mask is undefined!" );
        exit(11);
    }
}
//=======================================================================================
tcflag_t stopbits_mask(VSerialPort::StopBits s)
{
    switch(s)
    {
    case VSerialPort::StopBits::OneStop: return 0;
    case VSerialPort::StopBits::TwoStop: return CSTOPB;

    case VSerialPort::StopBits::OneAndHalfStop:
        assert( false && "I don't know how to set OneAndHalfStop bits mask!" );

    default:
        assert( false && "Stop bits mask is undefined!" );
        exit(12);
    }
}
//=======================================================================================
tcflag_t parity_mask(VSerialPort::ParityCheck pc)
{
    switch(pc)
    {
    case VSerialPort::ParityCheck::None: return 0;
    case VSerialPort::ParityCheck::Odd:  return PARENB | PARODD;
    case VSerialPort::ParityCheck::Even: return PARENB;

    default:
        assert( false && "ParityCheck bits mask is undefined!" );
        exit(13);
    }
}
//=======================================================================================




//=======================================================================================
class VSerialPort::Pimpl
{
public:
    int handle = 0;
};
//=======================================================================================
VSerialPort::VSerialPort()
    : p(new Pimpl)
{}
//=======================================================================================
VSerialPort::~VSerialPort()
{
    close();
}
//=======================================================================================


//=======================================================================================
bool VSerialPort::isOpened() const
{
    return p->handle > 0;
}
//=======================================================================================
bool VSerialPort::open_filename( const std::string &fname )
{
    filename = fname;
    return open();
}
//=======================================================================================
//http://www.opennet.ru/docs/RUS/serial_guide/

//Флаг O_NOCTTY говорит UNIX, что эта программа не хочет быть управляющим терминалом для этого порта. Если вы не укажете этого, то любой ввод (подобный сигналу абортирования от клавиатуры или что-нибудь подобное) будет затрагивать ваш процесс. Программы подобные getty(1M/8) используют эту возможность при старте логин-процесса, но обычно пользовательская программа не нуждается в таком поведении.

//Флаг O_NDELAY говорит UNIX, что эта программа не заботится о состоянии сигнала DCD, т.е. что другой конец линии запущен. Если вы не укажете этот флаг, то ваш процесс "заснет" до тех пор пока на линии DCD не появится уровень space (off).
bool VSerialPort::open()
{
    if (p->handle > 0)
        return false;


    p->handle = ::open( filename.c_str(), O_RDWR, O_EXCL );
    if (p->handle < 0)
        return false;

    //fcntl(portId_, F_SETFL, O_NONBLOCK);
    //В Linux данная команда может изменять только флаги O_APPEND, O_NONBLOCK, O_ASYNC и O_DIRECT.
    //fcntl(portId_, F_SETFL, O_ASYNC | O_RDWR | O_NOCTTY | O_NONBLOCK);

    struct termios trm_com;
    tcgetattr(p->handle, &trm_com);

    auto ok = cfsetspeed( &trm_com, to_speed_t(speed) );
    if ( ok != 0 ) return false;

    // C этими настройками надо долго курить мануалы, пока отложено в сторону.
    trm_com.c_oflag = ~(OPOST | OLCUC | ONLCR | OCRNL | ONLRET | OFILL | OFDEL);
    trm_com.c_oflag |= (NL0 | CR0 | TAB0 | BS0 | VT0 | FF0);
    trm_com.c_cflag &= ~(CSTOPB | PARENB | PARODD | HUPCL | CRTSCTS | CREAD | CLOCAL | CS8);
    // C этими настройками надо долго курить мануалы, пока отложено в сторону.


    trm_com.c_cflag |= databits_mask( dataBits );

    trm_com.c_cflag |= stopbits_mask( stopBits );

    trm_com.c_cflag |= parity_mask( parity );

//    if (control_RTS_CTS)
//        trm_com.c_cflag |= CRTSCTS;

    trm_com.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP | INLCR |
                         IGNCR | ICRNL | IXON | IXOFF | IUCLC | IXANY | IMAXBEL | IUTF8);


    trm_com.c_iflag |= IXOFF;

    if (flowControl)
        trm_com.c_iflag |= IXON;

    trm_com.c_lflag &= ~(ISIG | ICANON | XCASE | ECHO | ECHOE | ECHOK | ECHONL | ECHOCTL |
                         ECHOPRT | ECHOKE | FLUSHO | NOFLSH | TOSTOP | PENDIN | IEXTEN);

  //  trm_com.c_cc[VMIN]  = 0; // кол-во байт в пакете на прием
  //  trm_com.c_cc[VTIME] = 1; // десятые доли секунды в ожидании

    tcsetattr(p->handle, TCSANOW, &trm_com);

    return true;
}
//=======================================================================================
void VSerialPort::close()
{
    if (p->handle > 0)
        ::close(p->handle);

    p->handle = 0;
}
//=======================================================================================
int VSerialPort::read( VByteArray::value_type *buffer, int max_count )
{
    assert( buffer && max_count >= 0 );

    if ( !isOpened() )
        return -1;

    return ::read( p->handle, buffer, max_count );
}
//=======================================================================================
//  Читаем в буффер до тех пор, пока данные не кончатся.
VByteArray VSerialPort::readAll(bool *ok)
{
    if (ok) *ok = true;

    VByteArray res;
    VByteArray buf(one_buffer_size);
    while(1)
    {
        auto count = read(buf.data(), buf.size());
        if (count > 0)
            res.append( buf.begin(), buf.begin() + count );

        if ( count < 0 && ok )
            (*ok) = false;

        if ( count < int(buf.size()) )
            break;
    }
    return res;
}
//=======================================================================================
bool VSerialPort::send(const VByteArray &data)
{
    if (!isOpened())
        return false;

    auto w = ::write( p->handle, data.data(), data.size() );

    if (w == -1)
        varg("Error during send to port").cout_line();

    return w == int(data.size());
}
//=======================================================================================

//=======================================================================================
VGit "всасывает" в сборку сведения о последнем коммите в папке проекта.

//=======================================================================================
Для qmake необходимо определить переменную MAIN_DIR:
VLIBS_DIR = ...... где это хозяйство лежит
...
MAIN_DIR = $$PWD
include( $$VLIBS_DIR/vgit/vgit.pri )

//=======================================================================================
Для cmake можно переменную MAIN_DIR не определять, тогда она автоматически
инициализируется значением ${CMAKE_SOURCE_DIR}.
Зато после add_executable(...) следует включить еще vgit_post.cmake. Это нужно, чтобы
при изменении текущего коммита, cmake пересобирал информацию о нем.


set ( VLIBS_DIR ......где это хозяйство лежит )
...
# set ( MAIN_DIR ${CMAKE_SOURCE_DIR} ) -- можно не делать...
include( "$VLIBS_DIR/vgit/vgit.cmake" )
...
add_executable( ${PROJECT_NAME} "main.cpp" ${V_SOURCES} ${V_HEADERS} )

include( "${VLIBS_DIR}/vgit/vgit_post.cmake" ) # NB! НЕ ЗАБУДЬТЕ!!!!
unset ( QT_QMAKE_EXECUTABLE )
//=======================================================================================

//=======================================================================================
В коде можно использовать примерно так:

#include <iostream>
#include "vgit.h"

using std::cout;
using std::endl;

int main( int argc, char **argv )
{
    //  Если в аргументах есть что-нибудь, начинающееся на --vgit, то: если указан один
    //  из флагов --vgit-branch, --vgit-hash, --vgit-revcount, --vgit-date, vgit-author,
    //  печатает конкретный параметр (для автосборки информации, например)
    //  Если же будет --vgit-чегонибудькривое, то распечатает все показатели.
    VGit::print_and_exit_if_need( argc, argv );

    //  Все вместе.
    cout << VGit::as_message()  << std::endl;

    cout << VGit::hash()        << endl;
    cout << VGit::revcount()    << endl;
    cout << VGit::branch()      << endl;
    cout << VGit::author()      << endl;
    cout << VGit::date()        << endl;

    // Метка времени компиляции.
    // К git отношения не имеет, но здесь вполне уместно...
    cout << VGit::compile_datetime() << std::endl;

    return 0;
}
//=======================================================================================

//=======================================================================================
Принцип действия -- нужная информация собирается в переменные сборки выполнением команд:

git log -n 1 --pretty=format:"%H"
git rev-list HEAD --count
git symbolic-ref --short HEAD
git log -n 1 --pretty=format:"%an"
git log -n 1 --pretty=format:"%aI"

Далее, устанавливаются макросы в строку сборки компилятора (флагами -DMACRONAME=VALUE).
В vgit.cpp они преобразуются в соответствующие литералы и предоставляются уже в
нормальных строках.


Примечание: если на репе будет "оторванная голова" (DETACHED HEAD), команда 
"git symbolic-ref --short HEAD" выдаст ошибку и имя ветки сграблено не будет.

Сейчас в такой ситуации VGit::branch() возвращает "DETACHED HEAD", но не рассчитывайте на
такое поведение.
//=======================================================================================


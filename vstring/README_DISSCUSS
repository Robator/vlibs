//=======================================================================================
//      VString README_DISSCUSS
//=======================================================================================

    VString -- буффер для оперирования бинарными данными (не только, но это --
    основная задача).

//=======================================================================================
    Пример использования из реальной жизни:
    Есть такой протокол DCON: http://www.bookasutp.ru/Chapter2_10.aspx
    Там CRC записывается как остаток от суммы ASCII строки сообщения в HEX-е, пример:
    01010000008504030000000000000085000000011522211105081203483C10C4
    "C4" есть остаток суммы ASCII - символов. Вот так его можно извлечь:

    VString buffer = "01010000008504030000000000000085000000011522211105081203483C10C4";
    auto crc = buffer.take_back_str(2).from_hex().at(0);    // тривиально.

//=======================================================================================

        ВВЕДЕНИЕ

    Описанные ниже постулаты могут показаться банальными. Они банальные и есть.
Так подробно расписано, чтобы оставить недоразумениям как можно меньше шансов.
Не поленитесь, пробегитесь, пожалуйста, хотя бы по диагонали.

    Сериализованные данные представляют из себя банально подряд идущие друг за другом
байты. Порты, файлы и прочие сущности могут передавать их пакетами, или побайтно.
Системные функции передают и принимают их, обычно вот так:

    int any_send_or_receive( void* data, size_t size );

    Дальше начинается наша с вами работа -- их интерпретация. И вот тут возникает
целый зоопарк вариантов. Ниже перечислю те, с которыми приходится сталкиваться:

  * Текст. Казалось бы, банальнее не придумаешь, но, сразу же вспоминаем про то, что
    существует немерянное количество кодировок и методов их записи. По умолчанию,
    считаем кодировку UTF-8 (мир, вроде бы, очухался и на нее переезжают даже
    микромелкие). Она не простая, латиница соответствует ASCII, а остальные языки
    кодируются определенным образом и занимают от двух от шести байт (подробнее о методе
    кодирования расскажет гугл). Т.е.:
    vdeb << std::string( "Privet mir!" ).size(); // 11
    vdeb << std::string( "Привет мир!" ).size(); // 20
    По факту, является подмножеством бинарных данных.

  * Структуры, состоящие из полей разного размера, следующие друг за другом.

  * Поля фиксированной длины. Часто 1,2,4,8 байт, на эти размеры заточен этот класс.
    Бывают исключения, типа, трехбайтных или десятибайтных значений, но это экзотика.

    Могут интерпретироваться как целые или вещественные числа.

    Могут быть записаны в big или little endian. Для них введены аббревиатуры BE/LE
    (честно подглядел у IBEO, раньше пытался называтьь методы по принципу
    get_big()/get_little(). BE/LE гораздо удобнее и выразительнее). Я не упоминаю
    смешанную последовательность, надеюсь с этим адЪом встретиться не придеться.

  * HEX кодировка. Т.е. когда байт записывается двумя ASCII-символами 0-9, A-F.
    (Реализована)

  * Base64 кодировка. 6 бит в одном байте. Пока никому не нужна.

  * Битовые поля. Это отдельная тема, здесь не рассматривается (см. VBitMessage).

  * Ваш вариант...

//=======================================================================================

        ДИСКУРС

    Необходим буффер для удобной сериализации данных и парсинга сериализованных данных.
Если протокол текстовой, то, хотя бы, не мешать работать с ним стандартными средствами,
как со строкой. Если протокол бинарный -- обеспечить запись и чтение в/из буффера,
хотя бы, для арифметических типов в BE/LE последовательностях.

    //-----------------------------------------------------------------------------------
            typedef std::vector<uint8> ByteArray

    На диких просторах наших репозиториев пасется несчетное количество
    typedef-ов ByteArray-я:
http://192.168.0.203:17990/projects/ELSD/repos/lubd/browse/main/include/protocol/parser.h#17
http://192.168.0.203:17990/projects/ELSD/repos/nav_gw/browse/nav_gw_lib/components/lib/include/nav_gw_defs.h#15
http://192.168.0.203:17990/projects/ELSD/repos/nav_to_iss_converter_module/browse/components/lib/include/converter_defs.h#13-14
http://192.168.0.203:17990/projects/ELSD/repos/lubd/browse/main/include/serial/outer_port.h#18
http://192.168.0.203:17990/projects/ELSD/repos/nav_conf_lib/browse/components/lib/include/i_nav_conf.h#12-13
http://192.168.0.203:17990/projects/ELSD/repos/nav_gw/browse/nav_gw_lib/components/lib/include/udp_port.h#29
http://192.168.0.203:17990/projects/ELSD/repos/nav_gw/browse/nav_gw_lib/components/lib/include/tcp_client.h#24
http://192.168.0.203:17990/projects/ELSD/repos/nav_gw/browse/nav_gw_lib/components/lib/include/outer_port.h#17,18
    Хватит, пожалуй.
    Хорошо, что там хоть один и тот же тип определяется, спасибо великому копи-пасту.
На деле же, никакой пользы от таких буферов нету. Во-первых, они не предоставляют
способов безопасных чтения/записи. Во-вторых, в результате, в коде появляются, например,
вот такие конвертеры:
    static ByteArray str2ba(const std::string &str);
    static std::string ba2str(const ByteArray &ba);

http://192.168.0.203:17990/projects/ELSD/repos/nav_gw/browse/nav_gw_lib/components/test/source/test_nav_gw.cpp#23,25
http://192.168.0.203:17990/projects/ELSD/repos/canopen_gw/browse/canopen_isp_converter_module/components/lib/include/canopen_isp_converter_tools.h#68,75

    Использовать для текстовых протоколов буфер типа vector<uint8> неудобно и глупо,
т.к. нельзя, например подготовить команду вот так:
    vector<uint8> cmd = "some_cmd";
    У вектора просто нету соответствующего конструктора.

    То же касается и бинарных данных: загружать побайтно, например тип int -- то еще
удовольствие. Использовать memcpy -- небезопасно. И все это выглядит уродливо.

    Баста, больше не критикую, и так, чувствую, за критику закидают...

    //-----------------------------------------------------------------------------------
            VString : public std::string -- как универсальный буффер.

    Обратите внимание на пример с ba2str() <-> str2ba(): это очень очень характерное
преобразование в/из буффера. Остается сделать маленький шажок:

    строка (std::string) и есть буффер!

    А, действительно, чем строка символов не подходит на роль буффера? У нее "из коробки"
есть инструменты работы с текстом, и, следовательно, с текстовыми протоколами
(привет NMEA, DCON, HTTP etc). На самом деле, идея использовать строку как универсальный
буффер возникла не у автора, она давно и продуктивно используется, например библиотекой
CryptoPP, но ей вовсе не ограничивается.

    Вот с многобайтными полями придется поработать. А мы пишем на плюсах, нам классы
подавай. Поэтому класс VString написан как наследник от std::string, чтобы подмешать
интерфейс работы с многобайтовыми полями к текстовому интерфейсу.


//=======================================================================================

        КРИТИКА

    //-----------------------------------------------------------------------------------
A.  Класс std::string и так перегружен.

    Действительно, у string очень тяжелый интерфейс.
    http://www.cplusplus.com/reference/string/string/

    Его, в т.ч., критиковал дядюшка Саттер в 40 задачах (см. п. 5, стр. 242)
    https://vniias.atlassian.net/wiki/spaces/~A.Gromcev/pages/225116184
    Он, например, проехался катком и по конструкторам. Их там много. Есть алогичные. Про
    перегруженные методы я не говорю. Но! Этот класс внесен в Стандарт и, хочешь не
    хочешь, а пользоваться будешь. Если не лезть в дебри, то пользоваться классом не так
    уж и страшно, он хорошо работает на подавляющем большинстве повседневных задач.

    Задачи, которые возлагаются на хрупкие, тонкие плечи этого класса вовсе не тривиальны
    и, к сожалению, нельзя провести декомпозицию этих задач. Поэтому моструозный
    интерфейс должен окупаться эффективностью решения типичных задач. См. примеры.

    //-----------------------------------------------------------------------------------
B.  Кто тебя надоумил наследоваться от класса Стандартной библиотеки?

    Класс std::string выведен достаточно сложными путями с аллокаторами, типами и
    прочей машинерией, нормальному программисту не нужной. Но задача, которую
    решает класс VString -- подмешивание дополнительных методов к существующему
    стандартному интерфейсу. Такой фокус не сделает ничего плохого, до тех пор, пока
    не поменяется сигнатура данных класса. Поэтому, ни в коем случае нельзя добавлять
    в класс никаких дополнительных полей данных! Пока это условие выполняется, все будет
    хорошо.

    //-----------------------------------------------------------------------------------
C.  И все-таки, зачем наследоваться? Можно строку сделать /приватным/ полем класса.

    Тогда придется весь интерфейс строки проксировать, а это больше сотни методов.
    В VString пришлось проксировать все конструкторы std::string (для совместимости),
    заниматься проксированием всех остальных методов -- сизифов труд.
    Главное при наследовании -- VString _является_ std::string.

    //-----------------------------------------------------------------------------------
D.  А, вообще-то, строки бывают и состоящие из двух(четырех) байтовых символов!

    Тех которые wchar_t... Эта трава, была сделана для работы с UTF-16(32). Я не видел и,
    надеюсь, никогда не увижу, сборку, в которой стандартная строка собрана как
    basic_string<wchar_t>. Мне даже представить это страшно!

    Зато использование в качестве несущего байта char дает преимущества. Дело в том, что
    char на разных сборках имеет разный тип: знаковый или беззнаковый. Если "прибивать"
    байт типами int8/uint8, то это автоматически прибавляет ненужной работы по
    преобразованию в/из текста.

//=======================================================================================
//      VString README_DISSCUSS
//=======================================================================================
